#!/bin/bash

qmake

##########################################
# Test release version
##########################################
make release

n_errors=0

if [[ ! -f main ]]; then 
  echo "Incorrect: code does not compile cleanly with high warning levels"
  ((++n_errors))
fi

#####################
# Test exit states
#####################

./main > /dev/null
state_zero=`echo $?`

./main 1 > /dev/null
state_one=`echo $?`

./main 0 > /dev/null
state_zero=`echo $?`

./main 7 > /dev/null
state_seven=`echo $?`

./main nonsense > /dev/null
state_nonsense=`echo $?`

./main 1 2 > /dev/null
state_one_two=`echo $?`

if [[ ! $state_zero -eq 1 ]]; then
  echo "Incorrect: './int_to_word' must return in an exit state of 1, as there are too few arguments"
  ((++n_errors))
fi

if [[ ! $state_one -eq 0 ]]; then
  echo "Incorrect: './int_to_word 1' must return in an exit state of 0"
  ((++n_errors))
fi

if [[ ! $state_zero -eq 1 ]]; then
  echo "Incorrect: './int_to_word 0' must return in an exit state of 1, as 0 is a too small integer"
  ((++n_errors))
fi

if [[ ! $state_seven -eq 1 ]]; then
  echo "Incorrect: './int_to_word 7' must return in an exit state of 1, as 7 is a too big integer"
  ((++n_errors))
fi

if [[ ! $state_nonsense -eq 1 ]]; then
  echo "Incorrect: './int_to_word nonsense' must return in an exit state of 1, as 'nonsense' is no integer"
  ((++n_errors))
fi

if [[ ! $state_one_two -eq 1 ]]; then
  echo "Incorrect: './int_to_word 1 2' must return in an exit state of 1, as there are too many arguments"
  ((++n_errors))
fi

#####################
# Test output
#####################

# Create expected result
echo "one" > expected_1.txt
echo "two" > expected_2.txt
echo "three" > expected_3.txt
echo "four" > expected_4.txt
echo "five" > expected_5.txt
echo "six" > expected_6.txt

# Create the actual result
./main 1 > created_1.txt
./main 2 > created_2.txt
./main 3 > created_3.txt
./main 4 > created_4.txt
./main 5 > created_5.txt
./main 6 > created_6.txt

# Compare results
if ! cmp --silent created_1.txt expected_1.txt; then
  echo "Incorrect: './int_to_word 1' should literally display 'one', followed by a newline"
  ((++n_errors))
fi

if ! cmp --silent created_2.txt expected_2.txt; then
  echo "Incorrect: './int_to_word 2' should literally display 'two', followed by a newline"
  ((++n_errors))
fi

if ! cmp --silent created_3.txt expected_3.txt; then
  echo "Incorrect: './int_to_word 3' should literally display 'three', followed by a newline"
  ((++n_errors))
fi

if ! cmp --silent created_4.txt expected_4.txt; then
  echo "Incorrect: './int_to_word 4' should literally display 'four', followed by a newline"
  ((++n_errors))
fi

if ! cmp --silent created_5.txt expected_5.txt; then
  echo "Incorrect: './int_to_word 5' should literally display 'five', followed by a newline"
  ((++n_errors))
fi

if ! cmp --silent created_6.txt expected_6.txt; then
  echo "Incorrect: './int_to_word 6' should literally display 'six', followed by a newline"
  ((++n_errors))
fi

rm expected_*.txt
rm created_*.txt

#####################
# Test misc
#####################

# Avoid endls
n=`cat main.cpp | egrep "endl" | wc -l`
if [ ! "$n" -eq "0" ]; then
  echo "Incorrect: C++ Core Guidelines: SL.io.50: Avoid endl"
  ((++n_errors))
fi

# Catch exceptions by reference
n=`cat main.cpp | egrep "invalid_argument\s*\w*\s*\)" | wc -l`
if [ ! "$n" -eq "0" ]; then
  echo "Incorrect: C++ Core Guidelines: E.15: Catch exceptions from a hierarchy by reference"
  ((++n_errors))
fi

n=`cat main.cpp | egrep "out_of_range\s*\w*\s*\)" | wc -l`
if [ ! "$n" -eq "0" ]; then
  echo "Incorrect: C++ Core Guidelines: E.15: Catch exceptions from a hierarchy by reference"
  ((++n_errors))
fi

n=`cat main.cpp | egrep "exception\s*\w*\s*\)" | wc -l`
if [ ! "$n" -eq "0" ]; then
  echo "Incorrect: C++ Core Guidelines: E.15: Catch exceptions from a hierarchy by reference"
  ((++n_errors))
fi

# Exceptions should be const
n=`cat main.cpp | egrep "\(\w*(std::)?invalid_argument" | wc -l`
if [ ! "$n" -eq "0" ]; then
  echo "Incorrect: C++ Core Guidelines: Con.4: Use const to define objects with values that do not change after construction"
  ((++n_errors))
fi

n=`cat main.cpp | egrep "\(\w*(std::)?out_of_range" | wc -l`
if [ ! "$n" -eq "0" ]; then
  echo "Incorrect: C++ Core Guidelines: Con.4: Use const to define objects with values that do not change after construction"
  ((++n_errors))
fi

n=`cat main.cpp | egrep "\(\w*(std::)?exception" | wc -l`
if [ ! "$n" -eq "0" ]; then
  echo "Incorrect: C++ Core Guidelines: Con.4: Use const to define objects with values that do not change after construction"
  ((++n_errors))
fi

# Do not use ellipsis
n=`cat main.cpp | egrep "\(\w*\.\.\.\w*\)" | wc -l`
if [ ! "$n" -eq "0" ]; then
  echo "Incorrect: do not use ellipsis"
  ((++n_errors))
fi

##########################################
# Test debug version
##########################################
make debug
./main

#####################
# Test code coverage
#####################

n=`gcov -n -o debug main.cpp| head -n 2 | tail -n 1 | egrep "100\.00\%" | wc -l`
if [ ! "$n" -eq "1" ]; then
  echo "Incorrect: must have 100% code coverage. Current code coverage:"
  gcov -n -o debug main.cpp | head -n 2 | tail -n 1
  ((++n_errors))
fi

exit $n_errors
